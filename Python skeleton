import numpy as np
import matplotlib.pyplot as plt

# ==============================================================================
# ARES I-X USS PROBABILISTIC TRAJECTORY SUPERPOSITION MODEL
# Phenomenological envelope-matching implementation
# ==============================================================================

# -------------------------
# UNITS
# -------------------------
# Length: kilofeet (kft)
# Time: seconds (s)
# Velocity: kft/s
# Acceleration: kft/s^2

# -------------------------
# TIME DOMAIN
# -------------------------
t = np.linspace(0.0, 200.0, 800)
dt = t[1] - t[0]

# -------------------------
# BRANCH PARAMETERS
# -------------------------
num_branches = 50
np.random.seed(42)
alphas = np.random.dirichlet(np.ones(num_branches))  # Probabilities sum to 1

# -------------------------
# PHYSICAL CONSTANTS
# -------------------------
separation_altitude = 130.0        # kft
v_z0 = 0.6                         # kft/s (phenomenological fit)
g = 0.0322                         # kft/s^2 (gravity)

# -------------------------
# INITIAL CONDITIONS
# -------------------------
P_d = np.array([0.0, 0.0, separation_altitude])  # Position at divergence
theta_d = np.array([0.3, 0.3, 0.3])               # Orientation baseline
epsilon = 1.0                                     # Regularization

# -------------------------
# SUPERPOSITION STATE
# -------------------------
S_c = np.zeros((3, len(t)), dtype=complex)

# ==============================================================================
# BRANCH GENERATION
# ==============================================================================

for i in range(num_branches):
    alpha = alphas[i]

    # Initial perturbations
    pert_x, pert_y, pert_z = 0.2 * np.random.randn(3)

    # -------------------------
    # LATERAL MOTION
    # -------------------------
    X_i = pert_x * (1 + 0.04 * t) + 1.0 * np.sin(0.03 * t + i)
    Y_i = pert_y * (1 + 0.04 * t) + 0.8 * np.cos(0.04 * t + i)

    # -------------------------
    # VERTICAL (BALLISTIC + DRAG)
    # -------------------------
    Z_disp = v_z0 * t - 0.5 * g * t**2

    density_factor = np.clip(
        (140.0 - (separation_altitude + Z_disp)) / 60.0, 0.0, 1.0
    )

    if i < 2:
        drag = 0.007 * (1 + 2.5 * density_factor)
    elif i < 31:
        drag = 0.005 * (1 + 2.5 * density_factor)
    else:
        drag = 0.003 * (1 + 2.5 * density_factor)

    Z_disp *= np.exp(-drag * t)
    Z_disp += pert_z * 0.1 * np.sin(0.05 * t)

    # Enforce ground boundary without distorting curvature
    altitude = separation_altitude + Z_disp
    altitude = np.maximum(altitude, 0.0)
    Z_disp = altitude - separation_altitude

    # -------------------------
    # COMPLEX TRANSLATIONAL FIELD
    # -------------------------
    V_x = X_i + 1j * (-0.3 * Y_i)
    V_y = Y_i + 1j * (-0.3 * X_i)
    V_z = Z_disp + 1j * (0.1 * np.sin(0.1 * t))

    # -------------------------
    # ORIENTATION DYNAMICS
    # -------------------------
    tumble = (t >= 3.0).astype(float)

    roll  = 0.015 * t + 0.1 * np.sin(0.5 * t) * tumble
    pitch = 0.020 * t + 0.15 * np.cos(0.6 * t) * tumble
    yaw   = 0.010 * t + 0.2 * np.sin(0.7 * t) * tumble

    Theta_r = roll  + 1j * 0.04 * np.sin(0.4 * t)
    Theta_p = pitch + 1j * 0.04 * np.cos(0.5 * t)
    Theta_y = yaw   + 1j * 0.04 * np.sin(0.6 * t)

    # -------------------------
    # SUPERPOSITION ACCUMULATION
    # -------------------------
    S_c[0] += alpha * ((P_d[0] + V_x) / (theta_d[0] + Theta_r + epsilon))
    S_c[1] += alpha * ((P_d[1] + V_y) / (theta_d[1] + Theta_p + epsilon))
    S_c[2] += alpha * ((P_d[2] + V_z) / (theta_d[2] + Theta_y + epsilon))

# ==============================================================================
# OBSERVABLES
# ==============================================================================

pos_super = np.real(S_c)
im_super = np.abs(np.imag(S_c)).mean(axis=0)

# ==============================================================================
# METRICS
# ==============================================================================

apogee_idx = np.argmax(pos_super[2])
apogee_time = t[apogee_idx]
apogee_alt = pos_super[2][apogee_idx]

t130_idx = np.argmin(np.abs(t - 130.0))
alt_t130 = pos_super[2][t130_idx]

print("\n" + "=" * 70)
print("ARES I-X USS SUPERPOSITION MODEL")
print("=" * 70)
print(f"Branches: {num_branches}")
print(f"Apogee: {apogee_alt:.1f} kft @ {apogee_time:.0f} s")
print(f"Altitude @ 130 s: {alt_t130:.1f} kft")
print(f"Final Altitude: {pos_super[2][-1]:.1f} kft")
print(f"Mean Uncertainty (Im): {im_super.mean():.3f}")
print("=" * 70)

# ==============================================================================
# VISUALIZATION
# ==============================================================================

fig, ax = plt.subplots(figsize=(12, 8))
fig.patch.set_facecolor("black")
ax.set_facecolor("black")

for i in range(0, num_branches, 2):
    z_ex = v_z0 * t - 0.5 * g * t**2
    z_ex *= np.exp(-0.005 * t)
    z_ex += 0.12 * np.random.randn() * np.sin(0.05 * t)
    z_ex = np.maximum(separation_altitude + z_ex, 0.0)
    ax.plot(t, z_ex, color="cyan", alpha=0.35, linewidth=1)

ax.plot(t, pos_super[2], color="white", linewidth=4, label="Superposed Path")
ax.axvline(3, color="yellow", linestyle="--", label="BTM")
ax.axvline(130, color="red", linestyle="--", label="Max-Q")

ax.set_ylim(90, 160)
ax.set_xlabel("Time (s)", color="white")
ax.set_ylabel("Altitude (kft)", color="white")
ax.set_title("Ares I-X USS Branches & Superposition", color="white")
ax.tick_params(colors="white")
ax.legend(facecolor="black", labelcolor="white")
ax.grid(alpha=0.3)

plt.tight_layout()
plt.savefig("ares_ix_uss_superposition.png", dpi=200, facecolor="black")
plt.show()
